import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import linear_sum_assignment


def match_vertices_series(series, threshold_factor=1.7):
    """
    Matches corresponding vertices across multiple 2D projections and returns the series of coordinates for each point.

    Parameters:
        series (list of np.ndarray): List of 2D point sets, each representing a frame.
        threshold_factor (float): Multiplier for the mean distance threshold.

    Returns:
        list: List of coordinate series for each tracked point across frames.
    """
    all_matches = []
    point_tracks = {i: [tuple(series[0][i])] for i in range(len(series[0]))}  # Initialize tracking

    for i in range(len(series) - 1):
        points1, points2 = series[i], series[i + 1]

        # Compute pairwise Euclidean distance matrix
        cost_matrix = np.linalg.norm(points1[:, np.newaxis, :] - points2[np.newaxis, :, :], axis=2)

        # Solve assignment problem using Hungarian algorithm
        row_ind, col_ind = linear_sum_assignment(cost_matrix)
        matched_pairs = list(zip(row_ind, col_ind))

        # Compute distances of assigned pairs
        match_distances = [cost_matrix[i1, i2] for i1, i2 in matched_pairs]

        # Compute threshold
        distance_threshold = threshold_factor * np.mean(match_distances)

        # Filter out matches exceeding the threshold
        filtered_matches = [(i1, i2) for (i1, i2) in matched_pairs if cost_matrix[i1, i2] <= distance_threshold]

        all_matches.append(filtered_matches)

        # Update point tracks
        new_tracks = {}
        for i1, i2 in filtered_matches:
            if i1 in point_tracks:
                point_tracks[i1].append(tuple(points2[i2]))
                new_tracks[i2] = point_tracks[i1]  # Assign continuation to new index
            else:
                point_tracks[i2] = [tuple(points2[i2])]

        point_tracks = new_tracks  # Update tracking for next iteration

    return list(point_tracks.values()), all_matches


def plot_matching_series(series, all_matches):
    """
    Plots the matched points across multiple 2D projections.
    """
    for i in range(len(series) - 1):
        points1, points2 = series[i], series[i + 1]
        matches = all_matches[i]

        plt.figure(figsize=(6, 6))

        # Plot points from the first image (red)
        for j, (x, y) in enumerate(points1):
            plt.scatter(x, y, color='red', label="Frame " + str(i) if j == 0 else "", s=50)
            plt.text(x, y, f"{j}", fontsize=12, color='red', verticalalignment='bottom')

        # Plot points from the second image (blue)
        for j, (x, y) in enumerate(points2):
            plt.scatter(x, y, color='blue', label="Frame " + str(i + 1) if j == 0 else "", s=50)
            plt.text(x, y, f"{j}", fontsize=12, color='blue', verticalalignment='bottom')

        # Draw matching lines
        for i1, i2 in matches:
            x_values = [points1[i1, 0], points2[i2, 0]]
            y_values = [points1[i1, 1], points2[i2, 1]]
            plt.plot(x_values, y_values, 'gray', linestyle='dashed', alpha=0.7)

        plt.legend()
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.title(f"Vertex Correspondences Between Frame {i} and Frame {i + 1}")
        plt.gca().invert_yaxis()
        plt.show()


# Example usage
def grouping():
    series = [
        np.array([[419, 243], [394, 250], [414, 352], [430, 365], [454, 353], [436, 252]]),
        np.array([[427, 244], [400, 251], [415, 258], [414, 271], [399, 256], [401, 352], [414, 364], [443, 357],
                  [444, 253]]),
        np.array([[430, 245], [405, 255], [417, 265], [418, 278], [403, 262], [405, 358], [417, 368], [448, 360],
                  [449, 255]])
    ]

    tracked_series, all_matches = match_vertices_series(series)
    plot_matching_series(series, all_matches)

    print("Tracked Point Series:")
    print(tracked_series)


if __name__ == "__main__":
    grouping()
